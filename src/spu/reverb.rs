pub struct Reverb {
  pub mbase: u32,
  dapf1: u32,
  dapf2: u32,
  vlout: i16,
  vrout: i16,
  viir: i16,
  vcomb1: i16,
  vcomb2: i16,
  vcomb3: i16,
  vcomb4: i16,
  vwall: i16,
  vapf1: i16,
  vapf2: i16,
  vlin: i16,
  vrin: i16,
  mlsame: u32,
  mrsame: u32,
  mldiff: u32,
  mrdiff: u32,
  mlcomb1: u32,
  mlcomb2: u32,
  mlcomb3: u32,
  mlcomb4: u32,
  mrcomb1: u32,
  mrcomb2: u32,
  mrcomb3: u32,
  mrcomb4: u32,
  dldiff: u32,
  drdiff: u32,
  dlsame: u32,
  drsame: u32,
  mlapf1: u32,
  mlapf2: u32,
  mrapf1: u32,
  mrapf2: u32,
}

impl Reverb {
  pub fn new() -> Self {
    Self {
      mbase: 0,
      dapf1: 0,
      dapf2: 0,
      vlout: 0,
      vrout: 0,
      viir: 0,
      vcomb1: 0,
      vcomb2: 0,
      vcomb3: 0,
      vcomb4: 0,
      vwall: 0,
      vapf1: 0,
      vapf2: 0,
      vlin: 0,
      vrin: 0,
      mlsame: 0,
      mrsame: 0,
      mlcomb1: 0,
      mlcomb2: 0,
      mlcomb3: 0,
      mlcomb4: 0,
      mrcomb1: 0,
      mrcomb2: 0,
      mrcomb3: 0,
      mrcomb4: 0,
      dldiff: 0,
      drdiff: 0,
      dlsame: 0,
      drsame: 0,
      mlapf1: 0,
      mlapf2: 0,
      mrapf1: 0,
      mrapf2: 0,
      mldiff: 0,
      mrdiff: 0
    }
  }

  pub fn write_16(&mut self, address: u32, val: u16) {
    match address {
      0x1f80_1dc0 => self.dapf1 = (val as u32) * 8,
      0x1f80_1dc2 => self.dapf2 = (val as u32) * 8,
      0x1f80_1dc4 => self.viir = val as i16,
      0x1f80_1dc6 => self.vcomb1 = val as i16,
      0x1f80_1dc8 => self.vcomb2 = val as i16,
      0x1f80_1dca => self.vcomb3 = val as i16,
      0x1f80_1dcc => self.vcomb4 = val as i16,
      0x1f80_1dce => self.vwall = val as i16,
      0x1f80_1dd0 => self.vapf1 = val as i16,
      0x1f80_1dd2 => self.vapf2 = val as i16,
      0x1f80_1dd4 => self.mlsame = (val as u32) * 8,
      0x1f80_1dd6 => self.mrsame = (val as u32) * 8,
      0x1f80_1dd8 => self.mlcomb1 = (val as u32) * 8,
      0x1f80_1dda => self.mrcomb1 = (val as u32) * 8,
      0x1f80_1ddc => self.mlcomb2 = (val as u32) * 8,
      0x1f80_1dde => self.mrcomb2 = (val as u32) * 8,
      0x1f80_1de0 => self.dlsame = (val as u32) * 8,
      0x1f80_1de2 => self.drsame = (val as u32) * 8,
      0x1f80_1de4 => self.mldiff = (val as u32) * 8,
      0x1f80_1de6 => self.mrdiff = (val as u32) * 8,
      0x1f80_1de8 => self.mlcomb3 = (val as u32) * 8,
      0x1f80_1dea => self.mrcomb3 = (val as u32) * 8,
      0x1f80_1dec => self.mlcomb4 = (val as u32) * 8,
      0x1f80_1dee => self.mrcomb4 = (val as u32) * 8,
      0x1f80_1df0 => self.dldiff = (val as u32) * 8,
      0x1f80_1df2 => self.drdiff = (val as u32) * 8,
      0x1f80_1df4 => self.mlapf1 = (val as u32) * 8,
      0x1f80_1df6 => self.mrapf1 = (val as u32) * 8,
      0x1f80_1df8 => self.mlapf2 = (val as u32) * 8,
      0x1f80_1dfa => self.mrapf2 = (val as u32) * 8,
      0x1f80_1dfc => self.vlin = val as i16,
      0x1f80_1dfe => self.vrin = val as i16,
      _ => panic!("write to unhandled SPU address: {:X}", address)
    }
  }

  pub fn write_mbase(&mut self, val: u16) {
    self.mbase = (val as u32) * 8;
  }
}